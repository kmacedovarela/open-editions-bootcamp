{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Open Editions Bootcamp \u00b6 Welcome to the Open Editions Bootcamp. This series of hands-on exercises is designed to guide you through the essential aspects of process automation using BAMOE. Whether you are a developer or an architect, these labs will equip you with the skills needed to effectively leverage BAMOE for modern, cloud-native business automation solutions. Throughout this bootcamp, you will gain practical experience in designing, implementing, and deploying business processes. You will also explore how to integrate decision services and external systems within your automation workflows, all while utilizing the powerful tools provided by BAMOE. Info Some features covered in this bootcamp may be in tech preview. For the latest information on fully supported and tech preview features, please refer to the product documentation . By the end of these labs, you will: Understand the core components and architecture of BAMOE. Gain practical skills in designing, implementing, and deploying business processes. Learn to integrate decision services and external systems within your processes. Develop proficiency in using Canvas and VS Code for process authoring. About the Bootcamp \u00b6 In today's rapidly evolving business landscape, lightweight automation is key to efficiency and scalability on the cloud. Through these guides, developers and architects can gain hands-on experience with the latest capabilities of IBM Business Automation Manager Open Edition. Participants will explore the development experience and experiment with multiple capabilities for efficiently creating process automation solutions backed by open-source practices and IBM. Who Is This For \u00b6 This bootcamp is designed for technical users, such as developers and architects, who are seeking to explore the latest in business automation. It is ideal for professionals looking to deepen their knowledge of IBM BAMOE and how it can be used to create cloud-native solutions. What You'll Learn \u00b6 Get Started with Cloud-Native Business Automation : Discover the principles and benefits of cloud-native business automation and how IBM BAMOE enables it. Explore the Features of Development Tools : Dive into IBM BAMOE Canvas and IBM BAMOE Developer Tools for Microsoft VSCode, understanding their functionalities and how they enhance the development experience. Getting Started with Process Services : Learn the basics of creating and managing process services, and understand their role in business automation. Explore the Concepts of Process Automation : Understand the fundamental concepts and workflows involved in process automation, including modeling, execution, and monitoring. Leverage Event-Driven Capabilities in Process Automation : Explore how event-driven architecture can be integrated into process automation to enhance responsiveness and scalability. Deploying on OpenShift : Gain insights into deploying process and decision services on OpenShift, ensuring scalable and resilient operations. This bootcamp will equip you with the skills and knowledge needed to effectively utilize IBM Business Automation Manager Open Editions for modern, cloud-native business automation.","title":"Open Editions Bootcamp"},{"location":"#open-editions-bootcamp","text":"Welcome to the Open Editions Bootcamp. This series of hands-on exercises is designed to guide you through the essential aspects of process automation using BAMOE. Whether you are a developer or an architect, these labs will equip you with the skills needed to effectively leverage BAMOE for modern, cloud-native business automation solutions. Throughout this bootcamp, you will gain practical experience in designing, implementing, and deploying business processes. You will also explore how to integrate decision services and external systems within your automation workflows, all while utilizing the powerful tools provided by BAMOE. Info Some features covered in this bootcamp may be in tech preview. For the latest information on fully supported and tech preview features, please refer to the product documentation . By the end of these labs, you will: Understand the core components and architecture of BAMOE. Gain practical skills in designing, implementing, and deploying business processes. Learn to integrate decision services and external systems within your processes. Develop proficiency in using Canvas and VS Code for process authoring.","title":"Open Editions Bootcamp"},{"location":"#about-the-bootcamp","text":"In today's rapidly evolving business landscape, lightweight automation is key to efficiency and scalability on the cloud. Through these guides, developers and architects can gain hands-on experience with the latest capabilities of IBM Business Automation Manager Open Edition. Participants will explore the development experience and experiment with multiple capabilities for efficiently creating process automation solutions backed by open-source practices and IBM.","title":"About the Bootcamp"},{"location":"#who-is-this-for","text":"This bootcamp is designed for technical users, such as developers and architects, who are seeking to explore the latest in business automation. It is ideal for professionals looking to deepen their knowledge of IBM BAMOE and how it can be used to create cloud-native solutions.","title":"Who Is This For"},{"location":"#what-youll-learn","text":"Get Started with Cloud-Native Business Automation : Discover the principles and benefits of cloud-native business automation and how IBM BAMOE enables it. Explore the Features of Development Tools : Dive into IBM BAMOE Canvas and IBM BAMOE Developer Tools for Microsoft VSCode, understanding their functionalities and how they enhance the development experience. Getting Started with Process Services : Learn the basics of creating and managing process services, and understand their role in business automation. Explore the Concepts of Process Automation : Understand the fundamental concepts and workflows involved in process automation, including modeling, execution, and monitoring. Leverage Event-Driven Capabilities in Process Automation : Explore how event-driven architecture can be integrated into process automation to enhance responsiveness and scalability. Deploying on OpenShift : Gain insights into deploying process and decision services on OpenShift, ensuring scalable and resilient operations. This bootcamp will equip you with the skills and knowledge needed to effectively utilize IBM Business Automation Manager Open Editions for modern, cloud-native business automation.","title":"What You'll Learn"},{"location":"guides/00_intro/","text":"Getting started \u00b6 In this section you will become familiar with foundational concepts of the product and use the main features of Canvas with decisions based on DMN. Goals: Know the key components of IBM BAMOE. Set up your development environment. Become familiar with the use case. Explore the key features of Canvas through a Decision Automation perspective. Let's move forward and get a quick overview of IBM BAMOE and its components.","title":"Getting started"},{"location":"guides/00_intro/#getting-started","text":"In this section you will become familiar with foundational concepts of the product and use the main features of Canvas with decisions based on DMN. Goals: Know the key components of IBM BAMOE. Set up your development environment. Become familiar with the use case. Explore the key features of Canvas through a Decision Automation perspective. Let's move forward and get a quick overview of IBM BAMOE and its components.","title":"Getting started"},{"location":"guides/00_intro/02_bamoe_basics/","text":"Overview of IBM Business Automation Manager Open Editions \u00b6 Components \u00b6 IBM Business Automation Manager Open Editions (IBM BAMOE) is a comprehensive platform for automating business processes and decision services. It provides a range of tools and components that enable you to design, implement, and manage business automation solutions. Key Components \u00b6 IBM BAMOE consists of several core components essential for development, execution, and management of business automation processes. Development Tools Canvas : A web-based environment for designing and modeling business processes and decisions. IBM BAMOE Developer Tools for VS Code : Tools for developing business processes and decisions within the Visual Studio Code environment. Forms CLI : A command-line tool for generating web forms required for process execution. Execution Decision and Rules Engine : Executes decision models and business rules. Process Engine : Executes business process models. Management Management Console : Provides an interface for managing and monitoring process instances and tasks. Task Inbox : A user interface for viewing and interacting with user tasks in BAMOE process services. With a solid understanding of IBM BAMOE's main components, we will introduce the primary use case that will guide our hands-on exercises.","title":"Overview of IBM Business Automation Manager Open Editions"},{"location":"guides/00_intro/02_bamoe_basics/#overview-of-ibm-business-automation-manager-open-editions","text":"","title":"Overview of IBM Business Automation Manager Open Editions"},{"location":"guides/00_intro/02_bamoe_basics/#components","text":"IBM Business Automation Manager Open Editions (IBM BAMOE) is a comprehensive platform for automating business processes and decision services. It provides a range of tools and components that enable you to design, implement, and manage business automation solutions.","title":"Components"},{"location":"guides/00_intro/02_bamoe_basics/#key-components","text":"IBM BAMOE consists of several core components essential for development, execution, and management of business automation processes. Development Tools Canvas : A web-based environment for designing and modeling business processes and decisions. IBM BAMOE Developer Tools for VS Code : Tools for developing business processes and decisions within the Visual Studio Code environment. Forms CLI : A command-line tool for generating web forms required for process execution. Execution Decision and Rules Engine : Executes decision models and business rules. Process Engine : Executes business process models. Management Management Console : Provides an interface for managing and monitoring process instances and tasks. Task Inbox : A user interface for viewing and interacting with user tasks in BAMOE process services. With a solid understanding of IBM BAMOE's main components, we will introduce the primary use case that will guide our hands-on exercises.","title":"Key Components"},{"location":"guides/00_intro/03_use_case_overview/","text":"Use Case Overview \u00b6 The Credit Card Application Process is a comprehensive workflow that automates the evaluation and approval of credit card applications. This process ensures that applications are thoroughly evaluated and processed accurately. Objectives of the Business Process \u00b6 The primary objective of this process is to evaluate applicant data and decide whether to approve or reject the application. This ensures that only qualified applicants receive a credit card while minimizing risk for the financial institution. Key Steps in the Process \u00b6 Receive Application : Receive and parse the application. Validate initial data and assign a unique application ID. Evaluate Application : Assess the applicant's credit score and financial information. Applications with a credit score below 550 are automatically rejected. Applications with scores between 550 and 649 are sent for manual review. High scores (650 and above) are considered for further processing. Manual Review : Further scrutiny by a financial officer. Detailed analysis of the applicant's financial history and relevant factors. Generate Card Details : Once approved, generate necessary card details such as card number, CVV, expiration date, credit limit, and APR. Approval and Notification : Approved applicants receive their card details, while rejected applicants are informed of the reasons for rejection. Business Rules and External Validations \u00b6 The process incorporates several business rules to ensure accurate decision-making: - Credit Score Assessment : Determines initial eligibility based on predefined thresholds. - Debt-to-Income Ratio Check : Ensures applicants have a manageable level of debt relative to their income. - Fraud Risk Assessment : Uses external AI services to detect potential fraud, adding an extra layer of security. Approvals and Validations \u00b6 Automated Approvals : Based on clear-cut criteria such as credit score and debt-to-income ratio. Manual Approvals : Required for borderline cases where human judgment is necessary. External Service Validations : Involving AI-based fraud detection and other external checks to ensure data authenticity and reliability. Next, let's delve into the environment setup required to begin our journey with BAMOE.","title":"Use Case Overview"},{"location":"guides/00_intro/03_use_case_overview/#use-case-overview","text":"The Credit Card Application Process is a comprehensive workflow that automates the evaluation and approval of credit card applications. This process ensures that applications are thoroughly evaluated and processed accurately.","title":"Use Case Overview"},{"location":"guides/00_intro/03_use_case_overview/#objectives-of-the-business-process","text":"The primary objective of this process is to evaluate applicant data and decide whether to approve or reject the application. This ensures that only qualified applicants receive a credit card while minimizing risk for the financial institution.","title":"Objectives of the Business Process"},{"location":"guides/00_intro/03_use_case_overview/#key-steps-in-the-process","text":"Receive Application : Receive and parse the application. Validate initial data and assign a unique application ID. Evaluate Application : Assess the applicant's credit score and financial information. Applications with a credit score below 550 are automatically rejected. Applications with scores between 550 and 649 are sent for manual review. High scores (650 and above) are considered for further processing. Manual Review : Further scrutiny by a financial officer. Detailed analysis of the applicant's financial history and relevant factors. Generate Card Details : Once approved, generate necessary card details such as card number, CVV, expiration date, credit limit, and APR. Approval and Notification : Approved applicants receive their card details, while rejected applicants are informed of the reasons for rejection.","title":"Key Steps in the Process"},{"location":"guides/00_intro/03_use_case_overview/#business-rules-and-external-validations","text":"The process incorporates several business rules to ensure accurate decision-making: - Credit Score Assessment : Determines initial eligibility based on predefined thresholds. - Debt-to-Income Ratio Check : Ensures applicants have a manageable level of debt relative to their income. - Fraud Risk Assessment : Uses external AI services to detect potential fraud, adding an extra layer of security.","title":"Business Rules and External Validations"},{"location":"guides/00_intro/03_use_case_overview/#approvals-and-validations","text":"Automated Approvals : Based on clear-cut criteria such as credit score and debt-to-income ratio. Manual Approvals : Required for borderline cases where human judgment is necessary. External Service Validations : Involving AI-based fraud detection and other external checks to ensure data authenticity and reliability. Next, let's delve into the environment setup required to begin our journey with BAMOE.","title":"Approvals and Validations"},{"location":"guides/00_intro/04_env_setup/","text":"Environment Setup \u00b6 In this section, we will set up the necessary environment to start working with IBM Business Automation Manager Open Editions (BAMOE). Prerequisites \u00b6 Below is the list of technologies you will need. Java JDK 17 Maven 3.9.6 OpenShift 4.15 ( Need an OpenShift? Try the Dev Sandbox for Red Hat OpenShift for free. ) Git CLI Microsoft VSCode (latest version) (Need the IDE? Get it here: VSCode download page .) Tip For more information about the supported environments of IBM BAMOE, refer to the official documentation You may need an account on these websites in order to rely on easy to use cloud services in some of the exercises: GitHub - for versioning projects on GitHub Red Hat - For those using Dev Sandbox for OpenShift IBM - For using IBM's managed Kafka service Verifying Installed Software & Version To verify if you have the correct versions installed, you can use the following commands: java -version mvn -version oc version git --version Preparing VSCode and OpenShift Dev Sandbox \u00b6 If you have an OpenShift instance ready to use, and if the IBM BAMOE Dev Tools extension is already installed your VSCode IDE, you can jump to installing canvas Setting Up Local Development Environment with VS Code \u00b6 For running through the exercises, we'll use Visual Studio Code combined with IBM BAMOE Developer Tools Extension for Microsoft VSCode. Setting Up IBM BAMOE Developer Tools for VS Code \u00b6 To install BAMOE Dev Tools, open your IDE and go through the following steps: Go to the Extensions view by clicking on the Extensions icon in the Activity Bar on the side of the window or by pressing Ctrl+Shift+X . In the search box, type IBM BAMOE Developer Tools . Click the Install button for the IBM BAMOE Developer Tools extension. Need an OpenShift Environment? Developer Sandbox for Red Hat OpenShift \u00b6 To go through the OpenShift exercises, you'll need an OpenShift environment up and running. You can use any instance where you have access within a project. If you need a free, easy-to-setup OpenShift for our learning purposes, you can use the Developer Sandbox for Red Hat OpenShift . As stated by Red Hat: \"The Developer Sandbox for Red Hat OpenShift provides you with 30 days of no-cost access to a shared cluster on OpenShift, an enterprise-grade Kubernetes-based platform. Get instant access to your own minimal, preconfigured OpenShift environment for development and testing, hosted and managed by Red Hat.\" After you log-in and create a sandbox on the page above, you'll get to access your OpenShift: In this environment, you have access to a namespace named with your-username-dev (e.g. karina-varela-dev ). Login to access OpenShift from your Terminal \u00b6 To deploy BAMOE Canvas to OpenShift, you will need your OpenShift login token. Follow these steps to retrieve it using the OpenShift web console: Log in to the OpenShift Web Console : Open your web browser and navigate to your OpenShift cluster's web console URL. Enter your username and password to log in. Accessing the Token : Click on your username in the top-right corner of the console, and select \" Copy Login Command \" from the dropdown menu. A new page will open with your login token. Click on the \" Display Token \" button to view your token. Copy the login token provided. Using the Token to log-in in your terminal : Open your terminal. Log in to the OpenShift cluster using the oc CLI with the following command: oc login --token = <your-token> --server = <your-openshift-api-url> Next, let's install Canvas on OpenShift. Installing Canvas on Red Hat OpenShift Container Platform (OCP) \u00b6 IBM BAMOE Canvas is a web application that provides authoring tools for standards based business assets, directly in the browser. It allows users to create, edit, and manage decisions and processes, integrate with git for syncing repositories, and during development phase, deploy files to OpenShift and Kubernetes. To install Canvas on a container platform, we need to install three resources: Extended Services CORS Proxy IBM BAMOE Canvas Let's go through the installation and recall the purpose of these resources. Installation Steps \u00b6 In this section, we will install BAMOE Canvas on an OpenShift cluster. By using a manual installation process, you can have a better view of the resources created on OCP during the installation. Note Users who can install helm locally, can refer to the official documentation on how to Install Canvas with Helm . Installing Canvas on OpenShift \u00b6 Let's install Canvas , the environment we'll explore on the next lab for experimenting with automation services development with IBM BAMOE. Canvas is a powerful web application that provides tools for authoring decisions and workflows directly in the browser. It integrates seamlessly with Git for version control and with OpenShift for deploying your models for development validation purposes. Deploy Extended Services Extended Services are back-end services that provide additional features to Canvas, such as the DMN Runner (execution and validation of decision models) and a proxy (enables communication with OpenShift and Kubernetes clusters). export APP_PART_OF = bamoe-canvas-app export APP_NAME_EXTENDED_SERVICES = bamoe-extended-services oc new-app quay.io/bamoe/extended-services:9.1.0-ibm-0001 --name = $APP_NAME_EXTENDED_SERVICES oc create route edge --service = $APP_NAME_EXTENDED_SERVICES oc label services/ $APP_NAME_EXTENDED_SERVICES app.kubernetes.io/part-of = $APP_PART_OF oc label routes/ $APP_NAME_EXTENDED_SERVICES app.kubernetes.io/part-of = $APP_PART_OF oc label deployments/ $APP_NAME_EXTENDED_SERVICES app.kubernetes.io/part-of = $APP_PART_OF oc label deployments/ $APP_NAME_EXTENDED_SERVICES app.openshift.io/runtime = golang If you check your OpenShift console, you should be able to see the new pod is up and running. You can do the same observation for the next two deployments as well. Deploy CORS Proxy The CORS Proxy allows BAMOE Canvas to communicate with Git providers like GitHub, Gitlab and Bitbucket. export APP_NAME_CORS_PROXY = bamoe-cors-proxy oc new-app quay.io/bamoe/cors-proxy:9.1.0-ibm-0001 --name = $APP_NAME_CORS_PROXY oc create route edge --service = $APP_NAME_CORS_PROXY oc label services/ $APP_NAME_CORS_PROXY app.kubernetes.io/part-of = $APP_PART_OF oc label routes/ $APP_NAME_CORS_PROXY app.kubernetes.io/part-of = $APP_PART_OF oc label deployments/ $APP_NAME_CORS_PROXY app.kubernetes.io/part-of = $APP_PART_OF oc label deployments/ $APP_NAME_CORS_PROXY app.openshift.io/runtime = nodejs Deploy BAMOE Canvas Finally, deploy the BAMOE Canvas image, setting the environment variables required to connect it to the Extended Services and CORS Proxy backends. sh export APP_NAME_BAMOE_CANVAS=bamoe-canvas oc new-app quay.io/bamoe/canvas:9.1.0-ibm-0001 --name=$APP_NAME_BAMOE_CANVAS \\ --env=KIE_SANDBOX_EXTENDED_SERVICES_URL=https://$(oc get route $APP_NAME_EXTENDED_SERVICES --output jsonpath={.spec.host}) \\ --env=KIE_SANDBOX_CORS_PROXY_URL=https://$(oc get route $APP_NAME_CORS_PROXY --output jsonpath={.spec.host}) oc create route edge --service=$APP_NAME_BAMOE_CANVAS oc label services/$APP_NAME_BAMOE_CANVAS app.kubernetes.io/part-of=$APP_PART_OF oc label routes=$APP_NAME_BAMOE_CANVAS app.kubernetes.io/part-of=$APP_PART_OF oc label deployments/$APP_NAME_BAMOE_CANVAS app.kubernetes.io/part-of=$APP_PART_OF oc label deployments/$APP_NAME_BAMOE_CANVAS app.openshift.io/runtime=js Access IBM BAMOE Canvas If all went well, you should be able to see three pods - either on the OCP web console or using the cli to retrieve the pods of the current namespace: oc get pods . You should see something like: oc get pods NAME READY STATUS RESTARTS bamoe-canvas-54f87f584c-dpjr6 1 /1 Running 0 bamoe-cors-proxy-578bf787cb-rc4t8 1 /1 Running 0 bamoe-extended-services-6fdfd85b7b-xg82x 1 /1 Running 0 Your IBM BAMOE Canvas instance should be up and accessible. To get Canvas' URL, run this command: oc get route $APP_NAME_BAMOE_CANVAS --output jsonpath ={ .spec.host } ; echo The retrieved URL would look something like bamoe-canvas-username-dev.apps.sandbox-id.p1.openshiftapps.com/#/ . The URL should lead to your new installation of Canvas: With your development tools prepared, you're now ready to start exploring the solution in more detail. Let's move on to exploring Canvas with Decision Automation. Preparing Canvas for Integrating with Git and OpenShift \u00b6 To be able to use the maximum potential of Canvas, let's set up the integration with Git and OpenShift. In Canvas, execute the following procedures to set up the integration: Connect Canvas to OpenShift for Deployment and Integration \u00b6 In Canvas, click on the \"User\" icon on the top-right corner, and click on \"Connect to an account\". Select OpenShift. Enter the OpenShift API URL and your project name. You can obtain them through the web console or using the CLI commands below to retrieve the namespace, API URL, and authentication token respectively: oc project -q oc whoami --show-server oc whoami --show-token Configuration sample: Integration Successful: Save the settings. Your Canvas can now run dev deployments of your decision services on OpenShift! To wrap up, let's configure github integration. Connect Canvas to GitHub for Version Control and Collaboration \u00b6 In Canvas, go to the settings menu and select \"GitHub Integration\".! Click on Generate new token . You'll be redirected to the GitHub page where you can create a token for Canvas to authenticate on GitHub with the given permissions. In GitHub, create a new classic token Choose a note (any description for this token) and the permissions for 'repo' and 'gist' scopes. On the bottom of the page, click on \" Generate Token \". Copy and save the generated token, you'll need it in Canvas. Now back in Canvas, enter your GitHub repository URL and personal access token. You should see a green message informing you have Successfully connected . Awesome!! You're all set! With your development tools prepared, you're now ready to start exploring the solution in more detail. Let's move on to exploring Canvas with Decision Automation.","title":"Environment Setup"},{"location":"guides/00_intro/04_env_setup/#environment-setup","text":"In this section, we will set up the necessary environment to start working with IBM Business Automation Manager Open Editions (BAMOE).","title":"Environment Setup"},{"location":"guides/00_intro/04_env_setup/#prerequisites","text":"Below is the list of technologies you will need. Java JDK 17 Maven 3.9.6 OpenShift 4.15 ( Need an OpenShift? Try the Dev Sandbox for Red Hat OpenShift for free. ) Git CLI Microsoft VSCode (latest version) (Need the IDE? Get it here: VSCode download page .) Tip For more information about the supported environments of IBM BAMOE, refer to the official documentation You may need an account on these websites in order to rely on easy to use cloud services in some of the exercises: GitHub - for versioning projects on GitHub Red Hat - For those using Dev Sandbox for OpenShift IBM - For using IBM's managed Kafka service Verifying Installed Software & Version To verify if you have the correct versions installed, you can use the following commands: java -version mvn -version oc version git --version","title":"Prerequisites"},{"location":"guides/00_intro/04_env_setup/#preparing-vscode-and-openshift-dev-sandbox","text":"If you have an OpenShift instance ready to use, and if the IBM BAMOE Dev Tools extension is already installed your VSCode IDE, you can jump to installing canvas","title":"Preparing VSCode and OpenShift Dev Sandbox"},{"location":"guides/00_intro/04_env_setup/#installing-canvas-on-red-hat-openshift-container-platform-ocp","text":"IBM BAMOE Canvas is a web application that provides authoring tools for standards based business assets, directly in the browser. It allows users to create, edit, and manage decisions and processes, integrate with git for syncing repositories, and during development phase, deploy files to OpenShift and Kubernetes. To install Canvas on a container platform, we need to install three resources: Extended Services CORS Proxy IBM BAMOE Canvas Let's go through the installation and recall the purpose of these resources.","title":"Installing Canvas on Red Hat OpenShift Container Platform (OCP)"},{"location":"guides/00_intro/04_env_setup/#installing-canvas-on-openshift","text":"Let's install Canvas , the environment we'll explore on the next lab for experimenting with automation services development with IBM BAMOE. Canvas is a powerful web application that provides tools for authoring decisions and workflows directly in the browser. It integrates seamlessly with Git for version control and with OpenShift for deploying your models for development validation purposes. Deploy Extended Services Extended Services are back-end services that provide additional features to Canvas, such as the DMN Runner (execution and validation of decision models) and a proxy (enables communication with OpenShift and Kubernetes clusters). export APP_PART_OF = bamoe-canvas-app export APP_NAME_EXTENDED_SERVICES = bamoe-extended-services oc new-app quay.io/bamoe/extended-services:9.1.0-ibm-0001 --name = $APP_NAME_EXTENDED_SERVICES oc create route edge --service = $APP_NAME_EXTENDED_SERVICES oc label services/ $APP_NAME_EXTENDED_SERVICES app.kubernetes.io/part-of = $APP_PART_OF oc label routes/ $APP_NAME_EXTENDED_SERVICES app.kubernetes.io/part-of = $APP_PART_OF oc label deployments/ $APP_NAME_EXTENDED_SERVICES app.kubernetes.io/part-of = $APP_PART_OF oc label deployments/ $APP_NAME_EXTENDED_SERVICES app.openshift.io/runtime = golang If you check your OpenShift console, you should be able to see the new pod is up and running. You can do the same observation for the next two deployments as well. Deploy CORS Proxy The CORS Proxy allows BAMOE Canvas to communicate with Git providers like GitHub, Gitlab and Bitbucket. export APP_NAME_CORS_PROXY = bamoe-cors-proxy oc new-app quay.io/bamoe/cors-proxy:9.1.0-ibm-0001 --name = $APP_NAME_CORS_PROXY oc create route edge --service = $APP_NAME_CORS_PROXY oc label services/ $APP_NAME_CORS_PROXY app.kubernetes.io/part-of = $APP_PART_OF oc label routes/ $APP_NAME_CORS_PROXY app.kubernetes.io/part-of = $APP_PART_OF oc label deployments/ $APP_NAME_CORS_PROXY app.kubernetes.io/part-of = $APP_PART_OF oc label deployments/ $APP_NAME_CORS_PROXY app.openshift.io/runtime = nodejs Deploy BAMOE Canvas Finally, deploy the BAMOE Canvas image, setting the environment variables required to connect it to the Extended Services and CORS Proxy backends. sh export APP_NAME_BAMOE_CANVAS=bamoe-canvas oc new-app quay.io/bamoe/canvas:9.1.0-ibm-0001 --name=$APP_NAME_BAMOE_CANVAS \\ --env=KIE_SANDBOX_EXTENDED_SERVICES_URL=https://$(oc get route $APP_NAME_EXTENDED_SERVICES --output jsonpath={.spec.host}) \\ --env=KIE_SANDBOX_CORS_PROXY_URL=https://$(oc get route $APP_NAME_CORS_PROXY --output jsonpath={.spec.host}) oc create route edge --service=$APP_NAME_BAMOE_CANVAS oc label services/$APP_NAME_BAMOE_CANVAS app.kubernetes.io/part-of=$APP_PART_OF oc label routes=$APP_NAME_BAMOE_CANVAS app.kubernetes.io/part-of=$APP_PART_OF oc label deployments/$APP_NAME_BAMOE_CANVAS app.kubernetes.io/part-of=$APP_PART_OF oc label deployments/$APP_NAME_BAMOE_CANVAS app.openshift.io/runtime=js Access IBM BAMOE Canvas If all went well, you should be able to see three pods - either on the OCP web console or using the cli to retrieve the pods of the current namespace: oc get pods . You should see something like: oc get pods NAME READY STATUS RESTARTS bamoe-canvas-54f87f584c-dpjr6 1 /1 Running 0 bamoe-cors-proxy-578bf787cb-rc4t8 1 /1 Running 0 bamoe-extended-services-6fdfd85b7b-xg82x 1 /1 Running 0 Your IBM BAMOE Canvas instance should be up and accessible. To get Canvas' URL, run this command: oc get route $APP_NAME_BAMOE_CANVAS --output jsonpath ={ .spec.host } ; echo The retrieved URL would look something like bamoe-canvas-username-dev.apps.sandbox-id.p1.openshiftapps.com/#/ . The URL should lead to your new installation of Canvas: With your development tools prepared, you're now ready to start exploring the solution in more detail. Let's move on to exploring Canvas with Decision Automation.","title":"Installing Canvas on OpenShift"},{"location":"guides/00_intro/04_env_setup/#preparing-canvas-for-integrating-with-git-and-openshift","text":"To be able to use the maximum potential of Canvas, let's set up the integration with Git and OpenShift. In Canvas, execute the following procedures to set up the integration:","title":"Preparing Canvas for Integrating with Git and OpenShift"},{"location":"guides/00_intro/04_env_setup/#connect-canvas-to-github-for-version-control-and-collaboration","text":"In Canvas, go to the settings menu and select \"GitHub Integration\".! Click on Generate new token . You'll be redirected to the GitHub page where you can create a token for Canvas to authenticate on GitHub with the given permissions. In GitHub, create a new classic token Choose a note (any description for this token) and the permissions for 'repo' and 'gist' scopes. On the bottom of the page, click on \" Generate Token \". Copy and save the generated token, you'll need it in Canvas. Now back in Canvas, enter your GitHub repository URL and personal access token. You should see a green message informing you have Successfully connected . Awesome!! You're all set! With your development tools prepared, you're now ready to start exploring the solution in more detail. Let's move on to exploring Canvas with Decision Automation.","title":"Connect Canvas to GitHub for Version Control and Collaboration"},{"location":"guides/01_canvas_with_dmn/","text":"Getting Started with Exploring Canvas & Decisions \u00b6 In this section, you will become familiar with the foundational concepts of IBM Business Automation Manager Open Editions (BAMOE) and use the main features of Canvas for decision automation using DMN. Goals: \u00b6 Get to know Canvas and DMN Import and Explore Projects: Test your decision models directly in Canvas. Deploy your decision models on OpenShift using Canvas Dev Deployment. Explore and try the REST endpoints provided by decision services in BAMOE. Let's move forward and get a quick overview of the value of open standards for decision automation.","title":"Getting Started with Exploring Canvas &amp; Decisions"},{"location":"guides/01_canvas_with_dmn/#getting-started-with-exploring-canvas-decisions","text":"In this section, you will become familiar with the foundational concepts of IBM Business Automation Manager Open Editions (BAMOE) and use the main features of Canvas for decision automation using DMN.","title":"Getting Started with Exploring Canvas &amp; Decisions"},{"location":"guides/01_canvas_with_dmn/#goals","text":"Get to know Canvas and DMN Import and Explore Projects: Test your decision models directly in Canvas. Deploy your decision models on OpenShift using Canvas Dev Deployment. Explore and try the REST endpoints provided by decision services in BAMOE. Let's move forward and get a quick overview of the value of open standards for decision automation.","title":"Goals:"},{"location":"guides/01_canvas_with_dmn/01_introduction_canvas_dmn/","text":"Canvas & Decision Model and Notation (DMN) \u00b6 The Value of Open Standards for Decision Automation \u00b6 Why DMN, and What is it \u00b6 Decision Model and Notation (DMN) is an open standard that provides a powerful framework for decision automation. It offers a visual notation for decision modeling, a standardized approach to defining decision logic, and ensures interoperability between different tools and platforms. Designed to be easily understood by all stakeholders, from business users to developers, DMN enables the creation of executable models that can be run on various platforms, ensuring consistent decision-making processes. DMN is particularly valuable because it: - Enhances communication between business and technical teams through visual notation - Ensures consistency and clarity in decision logic across different systems - Facilitates sharing and reuse of models across various tools and platforms - Supports a wide range of decision logic, from simple rules to complex decision trees FEEL: A Standard Friendly Enough Expression Language \u00b6 FEEL (Friendly Enough Expression Language) is a key component of DMN that provides an intuitive way to express decision logic. Here are some examples of FEEL to give you an idea of its simplicity: Simple Conditional Logic : Checking if an applicant's age is above 18: if applicant.age > 18 then \"Eligible\" else \"Not Eligible\" String Manipulation : Concatenating the first name and last name of an applicant: applicant.firstName + \" \" + applicant.lastName List Operations : Calculating the average score from a list of scores: sum(scores) / count(scores) Date Operations : Calculating the number of days between two dates: days between startDate and endDate IBM & OMG: Working towards the evolution of DMN \u00b6 The collaboration between IBM and the Object Management Group (OMG) has been instrumental in the development and evolution of DMN. This partnership ensures continuous improvement of the standard, alignment with industry needs, and broader adoption across various sectors. Did you know The team behind Drools, an open-source decision management system, has been actively involved with OMG since the early days of DMN. They have consistently implemented the standard, even in its early versions. For more detailed information on Drools' implementation of DMN, you can explore Drools' documentation . Next, let's explore the development experience with Canvas, starting with connecting Canvas to OpenShift. Development Experience with Canvas \u00b6 Note If you haven't installed Canvas yet, please follow the installation guide here: Installing Canvas on OpenShift Connecting Canvas to GitHub \u00b6 To connect BAMOE Canvas to GitHub, follow these steps: Create a GitHub Personal Access Token: Go to GitHub Settings Click on \"Generate new token\" Select the required scopes for accessing your repositories Generate the token and copy it Configure Canvas with GitHub Token: Access BAMOE Canvas web interface Go to Settings Enter your GitHub personal access token in the provided field Save the configuration With these steps, BAMOE Canvas will be connected to your GitHub account, allowing you to import projects and synchronize your work. Great job! You now have a solid understanding of DMN and its value in decision automation. Let's dive into the development experience with Canvas.","title":"Canvas & DMN"},{"location":"guides/01_canvas_with_dmn/01_introduction_canvas_dmn/#canvas-decision-model-and-notation-dmn","text":"","title":"Canvas &amp; Decision Model and Notation (DMN)"},{"location":"guides/01_canvas_with_dmn/01_introduction_canvas_dmn/#the-value-of-open-standards-for-decision-automation","text":"","title":"The Value of Open Standards for Decision Automation"},{"location":"guides/01_canvas_with_dmn/01_introduction_canvas_dmn/#why-dmn-and-what-is-it","text":"Decision Model and Notation (DMN) is an open standard that provides a powerful framework for decision automation. It offers a visual notation for decision modeling, a standardized approach to defining decision logic, and ensures interoperability between different tools and platforms. Designed to be easily understood by all stakeholders, from business users to developers, DMN enables the creation of executable models that can be run on various platforms, ensuring consistent decision-making processes. DMN is particularly valuable because it: - Enhances communication between business and technical teams through visual notation - Ensures consistency and clarity in decision logic across different systems - Facilitates sharing and reuse of models across various tools and platforms - Supports a wide range of decision logic, from simple rules to complex decision trees","title":"Why DMN, and What is it"},{"location":"guides/01_canvas_with_dmn/01_introduction_canvas_dmn/#feel-a-standard-friendly-enough-expression-language","text":"FEEL (Friendly Enough Expression Language) is a key component of DMN that provides an intuitive way to express decision logic. Here are some examples of FEEL to give you an idea of its simplicity: Simple Conditional Logic : Checking if an applicant's age is above 18: if applicant.age > 18 then \"Eligible\" else \"Not Eligible\" String Manipulation : Concatenating the first name and last name of an applicant: applicant.firstName + \" \" + applicant.lastName List Operations : Calculating the average score from a list of scores: sum(scores) / count(scores) Date Operations : Calculating the number of days between two dates: days between startDate and endDate","title":"FEEL: A Standard Friendly Enough Expression Language"},{"location":"guides/01_canvas_with_dmn/01_introduction_canvas_dmn/#ibm-omg-working-towards-the-evolution-of-dmn","text":"The collaboration between IBM and the Object Management Group (OMG) has been instrumental in the development and evolution of DMN. This partnership ensures continuous improvement of the standard, alignment with industry needs, and broader adoption across various sectors. Did you know The team behind Drools, an open-source decision management system, has been actively involved with OMG since the early days of DMN. They have consistently implemented the standard, even in its early versions. For more detailed information on Drools' implementation of DMN, you can explore Drools' documentation . Next, let's explore the development experience with Canvas, starting with connecting Canvas to OpenShift.","title":"IBM &amp; OMG: Working towards the evolution of DMN"},{"location":"guides/01_canvas_with_dmn/01_introduction_canvas_dmn/#development-experience-with-canvas","text":"Note If you haven't installed Canvas yet, please follow the installation guide here: Installing Canvas on OpenShift","title":"Development Experience with Canvas"},{"location":"guides/01_canvas_with_dmn/01_introduction_canvas_dmn/#connecting-canvas-to-github","text":"To connect BAMOE Canvas to GitHub, follow these steps: Create a GitHub Personal Access Token: Go to GitHub Settings Click on \"Generate new token\" Select the required scopes for accessing your repositories Generate the token and copy it Configure Canvas with GitHub Token: Access BAMOE Canvas web interface Go to Settings Enter your GitHub personal access token in the provided field Save the configuration With these steps, BAMOE Canvas will be connected to your GitHub account, allowing you to import projects and synchronize your work. Great job! You now have a solid understanding of DMN and its value in decision automation. Let's dive into the development experience with Canvas.","title":"Connecting Canvas to GitHub"},{"location":"guides/01_canvas_with_dmn/02_explore_dmn/","text":"Exploring Canvas & Decisions \u00b6 In this section, we will import an existing DMN project into BAMOE Canvas and explore its decision models and automation capabilities. Value of DMN Automation \u00b6 Consistency : Ensures uniform application of eligibility criteria across all applications. Efficiency : Rapidly processes applications, reducing manual workload. Flexibility : Allows easy updates to decision logic without changing the underlying process. Transparency : Provides clear decision rationale, aiding in regulatory compliance. Scalability : Handles increasing application volumes without proportional increase in resources. Importing DMN Projects into Canvas \u00b6 To start, let's import a DMN file into Canvas. We will use a credit card eligibility use case to illustrate this process. Open Canvas in your browser. To import the DMN file, in Canvas go to the Import menu and select \"From URL\". Copy and paste the following link and click Import: [https://example.com/credit-card-eligibility.dmn](https://github.com/kmacedovarela/cc-application-approval-starter/blob/main/src/main/resources/CreditCardEligibility.dmn) Credit Card Eligibility DMN Model \u00b6 This DMN (Decision Model and Notation) model automates the initial eligibility assessment for credit card applications. It evaluates applicant information to determine whether an application should be automatically approved, rejected, or sent for manual review. Key Elements \u00b6 Input Node : Applicant information (age, credit score, annual income, student status) Decision Nodes : Eligibility Score Calculation: Assigns a score based on applicant criteria Determine Eligibility: Interprets the score to make a final decision Output : Eligibility result (Approved, Rejected, or Manual Review) Exploring the Decision Model \u00b6 Click on the Data Types tab. In it, you can see the Applicant type, which includes the attributes: age (Number), creditScore (Number), annualIncome (Number), and isStudent (Boolean). Now, click on the Editor tab and let's check the decision nodes. Click on the Eligibility Score Calculation node and observe it is of type Number and contains a decision table for calculating the eligibility score based on the applicant's criteria. Next, check the Determine Eligibility decision node, which is of type String and uses a FEEL expression to determine the eligibility result based on the calculated score. Running the Decision \u00b6 Click on the Run button to see the form that was automatically generated on the right side of the screen. Try out the decision using the test scenarios below. Test Scenarios Some examples of input and output data that can validate the decision: Is Student Annual Income Credit Score Age Expected Output false 30000 700 17 Rejected false 40000 500 25 Manual Review false 60000 720 30 Approved true 5000 600 19 Approved false 80000 650 45 Approved Using the Dev Deployment \u00b6 About the Dev Deployment \u00b6 Dev deployments in BAMOE Canvas allow you to deploy Decisions to both local Kubernetes instances and remote Kubernetes/OpenShift environments for development purposes. With it, you can deploy all Decisions within a project. After a short deployment process, you will be able to access a web application provided by BAMOE Canvas for testing and interacting with your Decisions. This web application includes a form similar to the one you used when running a decision in Canvas. Along with the form, it also provides access to the Swagger UI with the Decisions' API information. Tip Dev deployments are immutable, meaning if you need to make changes or if an error occurs, you must create a new deployment. Dev deployments can be easily managed and deleted from the Dev deployments dropdown. Steps to Deploy \u00b6 With the decision model opened, click on deploy. In the pop-up that opens up, choose the option \"Kogito Quarkus Blank App\" for \"Choose your deployment option\". Check the checkbox for \"Whether to deploy the DMN Form Webapp as a sidecar container or not\". Click on confirm. Click on \"Dev Deployments\" on the top menu bar to show the deployment status. When available (shows a green check), click on it to open the deployed service on a new page. A new browser tab will open on a URL similar to this: https://dev-deployment-yliell9512.apps.sandbox-m2.ll9k.p1.openshiftapps.com/form-webapp/#/form/Credit%20Card%20Eligibility%20Validation , showing an automatically generated form. !!! Note : Dev deployments are intended to be used for development purposes only, so users should not use the deployed services in production or for any type of business-critical workloads. Testing the REST APIs \u00b6 After opening the deployed service by opening the service URL, append /q/swagger-ui to the URL to access the APIs. This is based on OpenAPI. You can access the OpenAPI file by opening /q/openapi . Evaluating a Decision using REST \u00b6 Let's try using the POST endpoint available in swagger to fire a decision. Access the swagger ui in the deployed decision service. Locate and click on the endpoint: POST /Credit Card Eligibility Validation Click on edit to use the input: { \"Applicant\" : { \"isStudent\" : false , \"annualIncome\" : 30000 , \"creditScore\" : 700 , \"age\" : 17 } } Observe the output, which should be similar to: { \"Eligibility Score Calculation\" : 700 , \"Determine Eligibility\" : \"Rejected\" , \"Applicant\" : { \"isStudent\" : false , \"annualIncome\" : 30000 , \"creditScore\" : 700 , \"age\" : 17 } } Awesome!! You've successfully imported and explored a DMN project in Canvas. Now that you've seen how to model and test decisions.","title":"Exploring Canvas"},{"location":"guides/01_canvas_with_dmn/02_explore_dmn/#exploring-canvas-decisions","text":"In this section, we will import an existing DMN project into BAMOE Canvas and explore its decision models and automation capabilities.","title":"Exploring Canvas &amp; Decisions"},{"location":"guides/01_canvas_with_dmn/02_explore_dmn/#value-of-dmn-automation","text":"Consistency : Ensures uniform application of eligibility criteria across all applications. Efficiency : Rapidly processes applications, reducing manual workload. Flexibility : Allows easy updates to decision logic without changing the underlying process. Transparency : Provides clear decision rationale, aiding in regulatory compliance. Scalability : Handles increasing application volumes without proportional increase in resources.","title":"Value of DMN Automation"},{"location":"guides/01_canvas_with_dmn/02_explore_dmn/#importing-dmn-projects-into-canvas","text":"To start, let's import a DMN file into Canvas. We will use a credit card eligibility use case to illustrate this process. Open Canvas in your browser. To import the DMN file, in Canvas go to the Import menu and select \"From URL\". Copy and paste the following link and click Import: [https://example.com/credit-card-eligibility.dmn](https://github.com/kmacedovarela/cc-application-approval-starter/blob/main/src/main/resources/CreditCardEligibility.dmn)","title":"Importing DMN Projects into Canvas"},{"location":"guides/01_canvas_with_dmn/02_explore_dmn/#credit-card-eligibility-dmn-model","text":"This DMN (Decision Model and Notation) model automates the initial eligibility assessment for credit card applications. It evaluates applicant information to determine whether an application should be automatically approved, rejected, or sent for manual review.","title":"Credit Card Eligibility DMN Model"},{"location":"guides/01_canvas_with_dmn/02_explore_dmn/#key-elements","text":"Input Node : Applicant information (age, credit score, annual income, student status) Decision Nodes : Eligibility Score Calculation: Assigns a score based on applicant criteria Determine Eligibility: Interprets the score to make a final decision Output : Eligibility result (Approved, Rejected, or Manual Review)","title":"Key Elements"},{"location":"guides/01_canvas_with_dmn/02_explore_dmn/#exploring-the-decision-model","text":"Click on the Data Types tab. In it, you can see the Applicant type, which includes the attributes: age (Number), creditScore (Number), annualIncome (Number), and isStudent (Boolean). Now, click on the Editor tab and let's check the decision nodes. Click on the Eligibility Score Calculation node and observe it is of type Number and contains a decision table for calculating the eligibility score based on the applicant's criteria. Next, check the Determine Eligibility decision node, which is of type String and uses a FEEL expression to determine the eligibility result based on the calculated score.","title":"Exploring the Decision Model"},{"location":"guides/01_canvas_with_dmn/02_explore_dmn/#running-the-decision","text":"Click on the Run button to see the form that was automatically generated on the right side of the screen. Try out the decision using the test scenarios below. Test Scenarios Some examples of input and output data that can validate the decision: Is Student Annual Income Credit Score Age Expected Output false 30000 700 17 Rejected false 40000 500 25 Manual Review false 60000 720 30 Approved true 5000 600 19 Approved false 80000 650 45 Approved","title":"Running the Decision"},{"location":"guides/01_canvas_with_dmn/02_explore_dmn/#using-the-dev-deployment","text":"","title":"Using the Dev Deployment"},{"location":"guides/01_canvas_with_dmn/02_explore_dmn/#about-the-dev-deployment","text":"Dev deployments in BAMOE Canvas allow you to deploy Decisions to both local Kubernetes instances and remote Kubernetes/OpenShift environments for development purposes. With it, you can deploy all Decisions within a project. After a short deployment process, you will be able to access a web application provided by BAMOE Canvas for testing and interacting with your Decisions. This web application includes a form similar to the one you used when running a decision in Canvas. Along with the form, it also provides access to the Swagger UI with the Decisions' API information. Tip Dev deployments are immutable, meaning if you need to make changes or if an error occurs, you must create a new deployment. Dev deployments can be easily managed and deleted from the Dev deployments dropdown.","title":"About the Dev Deployment"},{"location":"guides/01_canvas_with_dmn/02_explore_dmn/#steps-to-deploy","text":"With the decision model opened, click on deploy. In the pop-up that opens up, choose the option \"Kogito Quarkus Blank App\" for \"Choose your deployment option\". Check the checkbox for \"Whether to deploy the DMN Form Webapp as a sidecar container or not\". Click on confirm. Click on \"Dev Deployments\" on the top menu bar to show the deployment status. When available (shows a green check), click on it to open the deployed service on a new page. A new browser tab will open on a URL similar to this: https://dev-deployment-yliell9512.apps.sandbox-m2.ll9k.p1.openshiftapps.com/form-webapp/#/form/Credit%20Card%20Eligibility%20Validation , showing an automatically generated form. !!! Note : Dev deployments are intended to be used for development purposes only, so users should not use the deployed services in production or for any type of business-critical workloads.","title":"Steps to Deploy"},{"location":"guides/01_canvas_with_dmn/02_explore_dmn/#testing-the-rest-apis","text":"After opening the deployed service by opening the service URL, append /q/swagger-ui to the URL to access the APIs. This is based on OpenAPI. You can access the OpenAPI file by opening /q/openapi .","title":"Testing the REST APIs"},{"location":"guides/03_process_automation/","text":"Getting Started with Process Automation \u00b6 In this section, you will become familiar with the foundational concepts of IBM Business Automation Manager Open Editions (BAMOE) and use the main features of Canvas for process automation using BPMN. Goals: \u00b6 Clone the starter project created with the accelerator using git Download to the computer to work on VSCode using the Dev Tools extensions Use Quarkus dev mode and use the management console and task inbox Expand the process design: Script Task, Human Task, Timer Event, Service Task Let's get started.","title":"Getting Started with Process Automation"},{"location":"guides/03_process_automation/#getting-started-with-process-automation","text":"In this section, you will become familiar with the foundational concepts of IBM Business Automation Manager Open Editions (BAMOE) and use the main features of Canvas for process automation using BPMN.","title":"Getting Started with Process Automation"},{"location":"guides/03_process_automation/#goals","text":"Clone the starter project created with the accelerator using git Download to the computer to work on VSCode using the Dev Tools extensions Use Quarkus dev mode and use the management console and task inbox Expand the process design: Script Task, Human Task, Timer Event, Service Task Let's get started.","title":"Goals:"},{"location":"guides/03_process_automation/00_intro_process/","text":"Running a basic process service \u00b6 About BPMN in BAMOE \u00b6 BPMN nodes provide a variety of functionalities to automate business processes. Here's a quick overview of some key BPMN nodes and their purposes: BPMN Node Purpose When to Use Example Script Task Execute code within process Quick, simple logic Calculate a value in JavaScript Service Task Invoke external services or custom Java code Integrate with other systems or process custom logic Call a REST API, or trigger a logic in a java class Human Task Involve human interaction Manual input/approval needed Assign approval to manager Timer Event Time-based events Scheduling, delays, timeouts Wait 24h before reminder Gateway Control process flow Decision points, parallel processing Route high-value orders differently DMN Task Execute complex decision logic automated decisions Determine credit eligibility Note on Automatic Marshalling \u00b6 BAMOE auto-maps process variables to DMN inputs/outputs by name and type. Here's a simplified explanation: Automatic Marshalling in BAMOE : The basic principle of this capability relies on BAMOE usage of Java reflection to convert POJOs (Plain Old Java Objects) to DMN data types and vice versa. It can be seen when: When passing data from process to DMN: It maps POJO fields to corresponding DMN input fields. When receiving data from DMN to process: DMN output is converted back into the appropriate Java object. Tip Matching Criteria: Field names in the POJO should match DMN input/output names. Data types should be compatible (e.g., Java String to DMN string). This automatic marshalling simplifies data exchange between BAMOE processes and DMN decision services, reducing the need for manual data transformation in many cases. Cloning the Project and Running Quarkus Dev Mode \u00b6 First, let's clone the starter project to your local repository and run it using Quarkus dev mode. Steps: \u00b6 Clone the Repository : git clone https://github.com/kmacedovarela/cc-application-approval-starter cd cc-application-approval-starter Run Maven Quarkus Dev Mode: mvn quarkus:dev Open the Browser and navigate to http://localhost:8080/q/dev-ui. Locate and click on Process instances in the jBPM Quarkus Dev UI add-on . Start a new process from the process definition list. Open the process details, and check the process instance progress, and the variable values. Awesome!! You've successfully cloned the project and started it using Quarkus dev mode. Next, let's explore how to extend the process design with various tasks in Canvas.","title":"Running a basic process service"},{"location":"guides/03_process_automation/00_intro_process/#running-a-basic-process-service","text":"","title":"Running a basic process service"},{"location":"guides/03_process_automation/00_intro_process/#about-bpmn-in-bamoe","text":"BPMN nodes provide a variety of functionalities to automate business processes. Here's a quick overview of some key BPMN nodes and their purposes: BPMN Node Purpose When to Use Example Script Task Execute code within process Quick, simple logic Calculate a value in JavaScript Service Task Invoke external services or custom Java code Integrate with other systems or process custom logic Call a REST API, or trigger a logic in a java class Human Task Involve human interaction Manual input/approval needed Assign approval to manager Timer Event Time-based events Scheduling, delays, timeouts Wait 24h before reminder Gateway Control process flow Decision points, parallel processing Route high-value orders differently DMN Task Execute complex decision logic automated decisions Determine credit eligibility","title":"About BPMN in BAMOE"},{"location":"guides/03_process_automation/00_intro_process/#note-on-automatic-marshalling","text":"BAMOE auto-maps process variables to DMN inputs/outputs by name and type. Here's a simplified explanation: Automatic Marshalling in BAMOE : The basic principle of this capability relies on BAMOE usage of Java reflection to convert POJOs (Plain Old Java Objects) to DMN data types and vice versa. It can be seen when: When passing data from process to DMN: It maps POJO fields to corresponding DMN input fields. When receiving data from DMN to process: DMN output is converted back into the appropriate Java object. Tip Matching Criteria: Field names in the POJO should match DMN input/output names. Data types should be compatible (e.g., Java String to DMN string). This automatic marshalling simplifies data exchange between BAMOE processes and DMN decision services, reducing the need for manual data transformation in many cases.","title":"Note on Automatic Marshalling"},{"location":"guides/03_process_automation/00_intro_process/#cloning-the-project-and-running-quarkus-dev-mode","text":"First, let's clone the starter project to your local repository and run it using Quarkus dev mode.","title":"Cloning the Project and Running Quarkus Dev Mode"},{"location":"guides/03_process_automation/00_intro_process/#steps","text":"Clone the Repository : git clone https://github.com/kmacedovarela/cc-application-approval-starter cd cc-application-approval-starter Run Maven Quarkus Dev Mode: mvn quarkus:dev Open the Browser and navigate to http://localhost:8080/q/dev-ui. Locate and click on Process instances in the jBPM Quarkus Dev UI add-on . Start a new process from the process definition list. Open the process details, and check the process instance progress, and the variable values. Awesome!! You've successfully cloned the project and started it using Quarkus dev mode. Next, let's explore how to extend the process design with various tasks in Canvas.","title":"Steps:"},{"location":"guides/03_process_automation/01_using_dmn_bpmn/","text":"Using DMN Decisions in Processes \u00b6 In this section, you will learn how to use DMN-based business rules task to automate decisions in your process, leveraging process variables and data types. In VSCode, open the process approval.bpmn , and delete the script task named Check Card Eligibility . Add a new business rules task to the process diagram, named Is Eligible . Configuring the Business Rules Task \u00b6 Configure the business rules task to consume the decision model. You can find and double check the information below, in the DMN file CreditCardEligibility.dmn available in your project: Rule Language: DMN Filename: CreditCardEligibility.dmn Namespace: https://kie.org/dmn/_639D6115-E08E-439D-8D29-45750C32DB28 Decision Name: IsEligible DMN Model Name: Credit Card Eligibility Validation Configure the inputs and outputs of the task, by clicking on Assignments and using the following info: Input : Applicant , org.acme.cc_approval.model.Applicant , applicant Output : IsEligible , String , approval Validating the DMN Configuration \u00b6 Open the DMN File and verify that the Applicant data type is part of the DMN model and matches the process variable. Now, open the class org.acme.cc_approval.model.Applicant and check the attributes there. See the similarity with the data type? The process variable applicant matches the data type in the DMN model, ensuring seamless data flow between the process and the decision model. Running the Process with DMN Automation \u00b6 Start Quarkus in Dev Mode: mvn quarkus:dev Open the Dev UI, navigate to http://localhost:8080/q/dev-ui . Start a new process instance from the approval process definition. Check Process Variables: Verify the variables of the completed instance to ensure the DMN decision was executed correctly. These test scenarios help you validate different outcomes based on the input data for the DMN-based decision automation. Test with different data that will result on different outcomes in the decision. Scenario Is Student Annual Income Credit Score Age Automatic Approval false 15000 750 25 Automatic Rejection false 15000 750 17 Manual Review false 30000 600 20 Stop Quarkus and close the dev ui in your browser. Configuring Different Outcomes Based on Automated Decisions \u00b6 Now, with the process working, let's add the gateways to handle the three possible scenarios: Automatic approval , Automatic rejection , Manual Approval . Add an exclusive gateway after the decision node, and let's configure the possible outcomes: a. Automatic Approval : - For the sequence flow leading to the approval end event, use the condition: return approval . toLowerCase (). equals ( \"approved\" ); b. Manual Approval : - For the sequence flow leading to the manual review end event, use the condition: return approval . toLowerCase (). equals ( \"manual\" ); c. Automatic Rejection : - For the sequence flow leading to the rejection end event, use the condition: return approval . toLowerCase (). equals ( \"rejected\" ); Add three different paths from the gateway, each leading to an end event. Connect each sequence flow to a respective end event. Generate the SVG diagram in VSCode to visualize the process. Run mvn quarkus:dev to start Quarkus in development mode. Start a new process instance and test the three different scenarios (approved, manual, rejected). Verify the instance details for each scenario. Close the dev-ui and stop quarkus. Awesome! You've successfully configured the process to handle different outcomes based on automated decisions. With the exclusive gateway and the conditions set for approval, manual review, and rejection, your process is now more dynamic and responsive. Next, let's proceed with using the service task to further enhance our process automation capabilities.","title":"Using DMN Decisions in Processes"},{"location":"guides/03_process_automation/01_using_dmn_bpmn/#using-dmn-decisions-in-processes","text":"In this section, you will learn how to use DMN-based business rules task to automate decisions in your process, leveraging process variables and data types. In VSCode, open the process approval.bpmn , and delete the script task named Check Card Eligibility . Add a new business rules task to the process diagram, named Is Eligible .","title":"Using DMN Decisions in Processes"},{"location":"guides/03_process_automation/01_using_dmn_bpmn/#configuring-the-business-rules-task","text":"Configure the business rules task to consume the decision model. You can find and double check the information below, in the DMN file CreditCardEligibility.dmn available in your project: Rule Language: DMN Filename: CreditCardEligibility.dmn Namespace: https://kie.org/dmn/_639D6115-E08E-439D-8D29-45750C32DB28 Decision Name: IsEligible DMN Model Name: Credit Card Eligibility Validation Configure the inputs and outputs of the task, by clicking on Assignments and using the following info: Input : Applicant , org.acme.cc_approval.model.Applicant , applicant Output : IsEligible , String , approval","title":"Configuring the Business Rules Task"},{"location":"guides/03_process_automation/01_using_dmn_bpmn/#validating-the-dmn-configuration","text":"Open the DMN File and verify that the Applicant data type is part of the DMN model and matches the process variable. Now, open the class org.acme.cc_approval.model.Applicant and check the attributes there. See the similarity with the data type? The process variable applicant matches the data type in the DMN model, ensuring seamless data flow between the process and the decision model.","title":"Validating the DMN Configuration"},{"location":"guides/03_process_automation/01_using_dmn_bpmn/#running-the-process-with-dmn-automation","text":"Start Quarkus in Dev Mode: mvn quarkus:dev Open the Dev UI, navigate to http://localhost:8080/q/dev-ui . Start a new process instance from the approval process definition. Check Process Variables: Verify the variables of the completed instance to ensure the DMN decision was executed correctly. These test scenarios help you validate different outcomes based on the input data for the DMN-based decision automation. Test with different data that will result on different outcomes in the decision. Scenario Is Student Annual Income Credit Score Age Automatic Approval false 15000 750 25 Automatic Rejection false 15000 750 17 Manual Review false 30000 600 20 Stop Quarkus and close the dev ui in your browser.","title":"Running the Process with DMN Automation"},{"location":"guides/03_process_automation/01_using_dmn_bpmn/#configuring-different-outcomes-based-on-automated-decisions","text":"Now, with the process working, let's add the gateways to handle the three possible scenarios: Automatic approval , Automatic rejection , Manual Approval . Add an exclusive gateway after the decision node, and let's configure the possible outcomes: a. Automatic Approval : - For the sequence flow leading to the approval end event, use the condition: return approval . toLowerCase (). equals ( \"approved\" ); b. Manual Approval : - For the sequence flow leading to the manual review end event, use the condition: return approval . toLowerCase (). equals ( \"manual\" ); c. Automatic Rejection : - For the sequence flow leading to the rejection end event, use the condition: return approval . toLowerCase (). equals ( \"rejected\" ); Add three different paths from the gateway, each leading to an end event. Connect each sequence flow to a respective end event. Generate the SVG diagram in VSCode to visualize the process. Run mvn quarkus:dev to start Quarkus in development mode. Start a new process instance and test the three different scenarios (approved, manual, rejected). Verify the instance details for each scenario. Close the dev-ui and stop quarkus. Awesome! You've successfully configured the process to handle different outcomes based on automated decisions. With the exclusive gateway and the conditions set for approval, manual review, and rejection, your process is now more dynamic and responsive. Next, let's proceed with using the service task to further enhance our process automation capabilities.","title":"Configuring Different Outcomes Based on Automated Decisions"},{"location":"guides/03_process_automation/02_using_service_tasks/","text":"Custom Logic with Service Tasks \u00b6 Adding a Service Task for Credit Card Generation \u00b6 When a card application is approved, we need to generate the credit card details. We can use Java to process this generation, providing a more flexible and powerful way to create the card information. Understanding the Service Class \u00b6 Open the CreditCardService class in your project. This class contains the logic for generating credit card details: @ApplicationScoped public class CreditCardService { public CreditCard generateCreditCardDetails ( Applicant applicant ) { double creditLimit = applicant . getAnnualIncome () * 0.3 ; return new CreditCard ( applicant . getName (), creditLimit ); } } This service calculates a credit limit based on 30% of the applicant's annual income and creates a new CreditCard object with the applicant's name and the calculated credit limit. Adding the Service Task to Your BPMN \u00b6 You can incorporate custom Java code into your processes using service tasks. Here's how to add and configure a service task for credit card generation: Open the approval process in VSCode. Add a new service task on the approved path, after the existing gateway and before the end node. Name the new service task \"Generate CC Details\". Configure the service task with these attributes: Implementation: java Interface: org.acme.cc_approval.service.CreditCardService Operation: generateCreditCardDetails The input assignment sends the process data as a parameter to the method, while the output assignment brings the method's return value back to the process and assigns it to a process variable. Assignments: - Input Assignment: - Name: applicant - Data Type: Applicant - Source: applicant - Output Assignment: - Name: creditCard - Data Type: CreditCard - Target: `creditCard Testing the Updated Process \u00b6 To test your updated process: Start Quarkus in dev mode using the command line. Open the Quarkus Dev UI in your browser. Start a new process instance with an approved application to see the card details in the instance data. Examine the process instance details, paying particular attention to the generated credit card values. After testing, close the Dev UI and stop Quarkus. By following these steps, you've successfully integrated a Java service task into your BPMN process to generate credit card details upon approval. This demonstrates how you can leverage custom Java code to enhance your business processes with complex logic and data manipulation.","title":"Custom Logic with Service Tasks"},{"location":"guides/03_process_automation/02_using_service_tasks/#custom-logic-with-service-tasks","text":"","title":"Custom Logic with Service Tasks"},{"location":"guides/03_process_automation/02_using_service_tasks/#adding-a-service-task-for-credit-card-generation","text":"When a card application is approved, we need to generate the credit card details. We can use Java to process this generation, providing a more flexible and powerful way to create the card information.","title":"Adding a Service Task for Credit Card Generation"},{"location":"guides/03_process_automation/02_using_service_tasks/#understanding-the-service-class","text":"Open the CreditCardService class in your project. This class contains the logic for generating credit card details: @ApplicationScoped public class CreditCardService { public CreditCard generateCreditCardDetails ( Applicant applicant ) { double creditLimit = applicant . getAnnualIncome () * 0.3 ; return new CreditCard ( applicant . getName (), creditLimit ); } } This service calculates a credit limit based on 30% of the applicant's annual income and creates a new CreditCard object with the applicant's name and the calculated credit limit.","title":"Understanding the Service Class"},{"location":"guides/03_process_automation/02_using_service_tasks/#adding-the-service-task-to-your-bpmn","text":"You can incorporate custom Java code into your processes using service tasks. Here's how to add and configure a service task for credit card generation: Open the approval process in VSCode. Add a new service task on the approved path, after the existing gateway and before the end node. Name the new service task \"Generate CC Details\". Configure the service task with these attributes: Implementation: java Interface: org.acme.cc_approval.service.CreditCardService Operation: generateCreditCardDetails The input assignment sends the process data as a parameter to the method, while the output assignment brings the method's return value back to the process and assigns it to a process variable. Assignments: - Input Assignment: - Name: applicant - Data Type: Applicant - Source: applicant - Output Assignment: - Name: creditCard - Data Type: CreditCard - Target: `creditCard","title":"Adding the Service Task to Your BPMN"},{"location":"guides/03_process_automation/02_using_service_tasks/#testing-the-updated-process","text":"To test your updated process: Start Quarkus in dev mode using the command line. Open the Quarkus Dev UI in your browser. Start a new process instance with an approved application to see the card details in the instance data. Examine the process instance details, paying particular attention to the generated credit card values. After testing, close the Dev UI and stop Quarkus. By following these steps, you've successfully integrated a Java service task into your BPMN process to generate credit card details upon approval. This demonstrates how you can leverage custom Java code to enhance your business processes with complex logic and data manipulation.","title":"Testing the Updated Process"},{"location":"guides/03_process_automation/04_using_human_task/","text":"User tasks for manual approval \u00b6 When the decision outcome indicates the need of a manual approval, the flow should move forward to a user task. Let's add this manual step in the process, and see it in action. About the process: - When an application requires manual review, it now goes to the \"Review Application\" task. - The assigned user (jdoe) reviews the application and decides to approve or reject it. - Based on the decision (stored in the approval variable), the process takes one of two paths: 1. If approved, it proceeds to generate credit card details. 2. If rejected, it ends the process immediately. Manual approval \u00b6 Add a new user task on your process, on the \"manual approval\" path. Configure the task with the name \"Review Application\", and: Set the Actor to: jdoe Input Assignment: Name: applicant Data Type: Applicant Source: applicant Output Assignment: Name: approval Data Type: String Target: approval Now, re-model your process so that it looks like this: You can configure the sequence flows after the human task such as: For the \"approved\" path: - Set the condition to: return approval.toLowerCase().equals(\"approved\"); For the \"rejected\" path: Set the condition to: return approval.toLowerCase().equals(\"rejected\"); Testing the Updated Process \u00b6 Start Quarkus in dev mode. Open the Quarkus Dev UI in your browser. Start a new process instance that would route to manual review. You should see a task assigned to user \"jdoe\". Switch to \"jdoe\" and complete the task, choosing either \"approved\" or \"rejected\". Observe how the process follows the appropriate path based on your decision. If approved, verify that credit card details are generated. If rejected, confirm that the process ends without generating card details. By adding this human task, you've introduced a crucial manual review step into your process, allowing for human decision-making in complex or borderline cases. This enhances the flexibility and robustness of your credit card approval process.","title":"User tasks for manual approval"},{"location":"guides/03_process_automation/04_using_human_task/#user-tasks-for-manual-approval","text":"When the decision outcome indicates the need of a manual approval, the flow should move forward to a user task. Let's add this manual step in the process, and see it in action. About the process: - When an application requires manual review, it now goes to the \"Review Application\" task. - The assigned user (jdoe) reviews the application and decides to approve or reject it. - Based on the decision (stored in the approval variable), the process takes one of two paths: 1. If approved, it proceeds to generate credit card details. 2. If rejected, it ends the process immediately.","title":"User tasks for manual approval"},{"location":"guides/03_process_automation/04_using_human_task/#manual-approval","text":"Add a new user task on your process, on the \"manual approval\" path. Configure the task with the name \"Review Application\", and: Set the Actor to: jdoe Input Assignment: Name: applicant Data Type: Applicant Source: applicant Output Assignment: Name: approval Data Type: String Target: approval Now, re-model your process so that it looks like this: You can configure the sequence flows after the human task such as: For the \"approved\" path: - Set the condition to: return approval.toLowerCase().equals(\"approved\"); For the \"rejected\" path: Set the condition to: return approval.toLowerCase().equals(\"rejected\");","title":"Manual approval"},{"location":"guides/03_process_automation/04_using_human_task/#testing-the-updated-process","text":"Start Quarkus in dev mode. Open the Quarkus Dev UI in your browser. Start a new process instance that would route to manual review. You should see a task assigned to user \"jdoe\". Switch to \"jdoe\" and complete the task, choosing either \"approved\" or \"rejected\". Observe how the process follows the appropriate path based on your decision. If approved, verify that credit card details are generated. If rejected, confirm that the process ends without generating card details. By adding this human task, you've introduced a crucial manual review step into your process, allowing for human decision-making in complex or borderline cases. This enhances the flexibility and robustness of your credit card approval process.","title":"Testing the Updated Process"}]}